====================================
理解常用網路協議
====================================

:slug: common_network_protocols
:lang: zht
:date: 2017-04-18 16:31
:modified: 2017-06-09 14:36
:tags: protocol, tcp, ip, udp
:description: 本文是一篇關於基礎網路協議，比如 TCP, IP, UDP 等的歸納介紹，以便於系統化地理解。（還沒寫完）
:license: 本文以譯文形式引用了一些 https://en.wikipedia.org & https://tools.ietf.org/html/ 上的相關內容

.. contents::

OSI & TCP/IP 參考模型
==============================

理解協議之前先說說兩個計算機系統之間通訊的常用概念模型:

OSI
  :ruby:`開放系統互聯參考模型|Open System Interconnect Reference Model`，是用於特徵化標準化電信通訊/計算機間通訊(而不需要關心其底層實現和技術細節)而被國際標準化組織定製的，其一共有 7 個抽象層。

TCP/IP 參考模型
  | 同樣是一個概念模型，其實它正式的名稱應該是 :ruby:`網際網路協議套件|Internet protocol suite`，因為其原始協議為 TCP 和 IP 協議而被一般稱為 TCP/IP 參考模型。它有時也因為其開發受到美國國防部下屬機構資助而以 :ruby:`DoD 模型|Department of Defense Model` 被人知曉。
  | 這個套件包含了一系列常用的網路通訊協議，定義了端對端通訊如何打包、確定地址、傳送、路由定址、接收資料。它一共有 4 個抽象層。

注意的是，這邊並不討論過於抽象化的概念，僅僅是描述以便於理解各協議作用和相互的聯絡。
  
兩個概念模型的抽象層對比:

+------------------------------+------------------------------+------------------------------+
|          OSI Model           |        Protocol Examples     |          TCP/IP Model        |
+==============================+==============================+==============================+
|       Application Layer      |   DNS,FTP,HTTP,Telnet,SMTP   |                              |
+------------------------------+------------------------------+                              |
|      Presentation Layer      |        TLS,MIME,XDR          |       Application Layer      |
+------------------------------+------------------------------+                              |
|         Session Layer        |         PPTP,SOCKS           |                              |
+------------------------------+------------------------------+------------------------------+
|       Transport Layer        |          TCP,UDP             |        Transport Layer       |
+------------------------------+------------------------------+------------------------------+
|         Network Layer        |        IP,ICMP,IPsec         |         Internet Layer       |
+------------------------------+------------------------------+------------------------------+
|        Data Link Layer       |       ARP,NDP,MAC,PPP        |                              |
+------------------------------+------------------------------+           Link Layer         |
|        Physical Layer        | DSL,IEEE802.11,USB,Bluetooth |                              |
+------------------------------+------------------------------+------------------------------+


資料包在傳送時會先一層層地新增各種協議頭，而在接收時則一層層剝去各種協議頭，以接收一個 http 協議資料為例:

.. ditaa::
  :alt: http 封包過程

                                                                  +-------------+------------+
                                                                  | HTTP Header | Plain Text +--=-----------------------Application Layer
                                             +--------------------+-------------+------------+
                                             |c1EE TCP Header     |       HTTP Data          +--=-----------------------Transport Layer
                         +-------------------+--------------------+--------------------------+
                         |cGRE IP Header     |c1EE                TCP Data                   +--=-----------------------Internet Layer
  +----------------------+-------------------+-----------------------------------------------+---------------------+
  |cBLU Frame Header     |cGRE                          IP Data                              |cBLU Frame Trailer   |\
  +----------------------+-------------------------------------------------------------------+---------------------+ -=-Link Layer
  |cBLK                                                Bit Stream                                                  |/
  +----------------------+-----------------------------------------------------------------------------------------+

這是一個簡單且常見的例子，如果被通過 TLS 加密了的話，那麼在添加了 HTTP Header 後會給整個 HTTP Data 做加密後再次新增 TCP Header 。

針對 TCP/IP 模型來看，雖然普遍認為是 4 層模型，但是如果把 Link Layer 再劃分兩層來看對於裝置/資料方面的描述往往會更加方便，這也就是一些 5 層 TCP/IP 模型的說法了。依舊看圖:

.. ditaa::
  :alt: TCP/IP 模型圖解

                    A unit of data which is specified in a protocol of a given layer
                    and which consists of protocol-control information and possibly
                    user data of that layer.
                   ----------------------------+-----\SDU(Service Data Unit) is
                                               |     |the payload of a given PDU.
                                               :     |
                                               v     |The PDU specifies the data that
                                 Protocol Data Unit  |will be sent to the peer protocol
  +-------------------------+     /------+           |layer at the receving end, while
  |     Application Layer   |-=---| Data |           |SDU just for a lower layer.
  +-------------------------+     +------/
                                                     /-\
  +-------------------------+     /---------------+  : |Divided from a big data to
  |c1EE Transport Layer     |-=---| Segment(TCP)  |<-/ |maximize the probability
  +-------------------------+     +---------------+    |that it can be delivered
                                  | Datagram(UDP) |<-\ |correctly to the destination.
                                  +---------------/  | |Consists of a header and a
                                                     : |data payload.
  +-------------------------+     /--------+         |
  |cGRE Internet Layer      |-=---| Packet |         |
  +-------------------------+     +--------/         |Consists of a header and a data
                                                     |payload, provides a connectionless
  +-------------------------+     /-------+          |communication service.
  |cBLU Data Link Layer     |-=---| Frame |
  +-------------------------+     +-------/

  +-------------------------+     /-----+
  |cBLK Physical Layer      |-=---| Bit |
  +-------------------------+     +-----/

Packet, Frame, Bit 不再敘述，理解為對應層的簡單表述單位即可，至於哪些具體裝置用在哪一層，這個看裝置功能對應的協議即可。

IP
==============================

IP(Internet Protocol) 位於 OSI 模型的第三層，用於封裝上層資料包給其新增 IP 頭傳給下層。這是一個無狀態的協議。

IPv4
----------------------------------------

在 :rfc:`791` 中定義

IP 頭格式及欄位說明
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

頭格式如下:

+---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|bit| 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
+===+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+
|  0|  Version  |    IHL    |       DSCP      | ECN |                 Total Length                  |
+---+-----------+-----------+-----------------+-----+--------+--------------------------------------+
| 32|                   Identification              |  Flags |           Fragment Offset            |
+---+-----------------------+-----------------------+--------+--------------------------------------+
| 64|     Time to Live      |        Protocol       |               Header Checksum                 |
+---+-----------------------+-----------------------+-----------------------------------------------+
| 96|                                      Source IP Address                                        |
+---+-----------------------------------------------------------------------------------------------+
|128|                                   Destination IP Address                                      |
+---+-------------------------------------------------------------------------+---------------------+
|160|                          Options (if IHL > 5)                           |       Padding       |
+---+-------------------------------------------------------------------------+---------------------+

欄位說明:

Version
  0100, 即十進位制的 4 ，單純的版本號

IHL
  :ruby:`因特網報頭長度|Internet Header Length` 顧名思義，定義了 IP 頭的長度，其中一個 bit 代表 32bits 的長度。因為 Options 是可變的，所以最小為 0101(160bits)，而最大為 1111(480bits)。

DSCP
  :ruby:`差分服務程式碼點|Differentiated Services Code Point` 在 :rfc:`2474` 中定義，這個 6bits 的欄位服務於 :ruby:`差分服務|DiffServ` 的，差分服務是一個計算機網路架構，其定義了一個簡單、可擴充套件的粗粒度的網路流量分類和管理機制，併為現代網路提供了 :ruby:`服務質量|Quality of Service` 。

ECN
  | :ruby:`顯式擁塞通知|Explicit Congestion Notification` 在 :rfc:`3168` 中定義，它提供了端端間在不丟失資料包的情況下的網路擁塞通知（需要網路基礎裝置支援並且通訊兩端啟用的情況下）。
  | DSCP 欄位和 ECN 欄位替換了過時的 :ruby:`服務型別|Type of Service` 欄位。

Total Length
  以位元組為單位定義了整個 IP 包的大小。最少為 20 位元組（只有包頭沒有負載的情況下），最大為 65535(0xffff) 位元組。規定所有主機必須支援最小 576 位元組的 IP :ruby:`資料報|datagram` [1]_，不過有時候鏈路本身可能會限制的更加厲害，那麼超出大小的資料報就會 :ruby:`被分片|be fragmented` ， 這將由主機或者路由器所處理。

Identification
  用於識別屬於單獨一個數據報的一組碎片，不過有一些試驗性的工作也建議把這個用在其他的方面，比如新增包追蹤資訊以幫助追蹤用有欺騙性源地址的資料報，但是 :rfc:`6864` 已經禁止這樣子的使用了。

Flags
  3 個用於控制/識別碎片的 bit 欄位:

  * bit0: 保留欄位，必須置 1
  * bit1: (DF) 0 = :ruby:`可以分片|May Fragment` ， 1 = :ruby:`禁止分片|Don't Fragment` ，在 DF 被置 1 的情況下，如果路由必須分片資料報後才傳送，則該資料報會被丟棄，一般用在當需要傳送給沒有足夠資源處理碎片的主機的情況下。這個位也可以用來做 :ruby:`路徑最大傳輸單元發現(PMTUD)|Path Maximum Transmission Unit Discovery` 。
  * bit2: (MF) 0 = :ruby:`最後的碎片|Last Fragment` ， 1 = :ruby:`更多碎片|More Fragments` ，對於被分片的資料報來說， 除了最後一個的其它碎片 MF 都被置 1，最後一個置 0，如何將最後一個碎片與其它未被分片的資料報區分，則依賴下一個描述欄位。

Fragment Offset
  碎片偏移量以 8 位元組塊為一個單位，第一個碎片偏移量為 0，最大的偏移量為 :math:`(2^{13} - 1) \times 8 = 65528 \text{ bytes}` ，加上 IP 頭的最小長度，可以達到 IP 資料報的最大長度了。而區分一個碎片組的最後一個碎片和未被分片的資料報，也是由這個欄位來判斷的。

Time To Live
  8 位的 TTL 欄位限制了資料報的生命週期，避免了其被永遠得留在網路上。這個欄位在理論上是以秒為單位的，不過每一個 :ruby:`躍點|hop` 最少也需要給 TTL 減一，所以實際上使用是按照躍點限制數來使用的， IPv6_ 中也已經做了欄位的重新命名。當 TTL 欄位變成 0 時，當前躍點會丟棄這個資料報，併發送一個 ICMP 超時報文(Type=11)給該資料報傳送者。

Protocol
  定義了 IP 資料報的資料部分所使用的協議型別，詳細的協議序號可以看 `List of IP Protocol Number`_ 。

Header Checksum
  IP 頭校驗和是用來被路由檢查當前 IP 包的頭是否正確完整的。它是一個 16 位的把 IP 頭以 16 位反碼格式相加的和的 :ruby:`反碼|one's complement` [2]_ ，計算校驗和時需要把本欄位全置 0。每當資料報到達一個路由後，會先計算頭的校驗和和頭本身提供的進行比較以驗證，如果校驗和不匹配則丟棄該資料報，匹配的情況下則減小 TTL 值，並重新計算校驗和。至於如何計算校驗和和驗證的，舉例如下:

    .. compound::

      | *以下數全以 16 進製表示*
      | 假設有一個 IP 頭 **4500 0034 eb35 4000 4006 d1fc 0a00 0713 2f5a 3d25** ，其中 **d1fc** 就是其攜帶的 IP Header Checksum

      計算校驗和
        | 替換校驗和欄位為全 0 後相加 **4500 + 0034 + eb35 + 4000 + 4006 + 0000 + 0a00 + 0713 + 2f5a + 3d25 = 22e01**
        | 因為機制是需要以 16 位反碼格式相加，可以注意到這邊出現了迴圈進位的情況，那麼再次相加 **0002 + 2e01 = 2e03**
        | 再取其反碼 **~2e03 = d1fc**
      
      驗證校驗和
        只需要在計算時不替換校驗和欄位內容，以計算校驗和相同方式進行計算，判斷最後結果是否為 **0000** 即可。

Source Address
  定義了資料包傳送者所對應的地址，可以被 :ruby:`網路地址轉換|network address translation` 裝置所修改。

Destination address
  定義了資料包接收者所對應的地址，同樣可以被網路地址轉換裝置所修改。

Options
  | 這個欄位是可選的，當 IHL 大於 5 時意味著這個欄位存在有內容。當本欄位的結束位置和 IP 頭結束位置不一致時，需要在本欄位結束位置加上 :ruby:`EOL(0x00)|End of Option List` 選項。
  | 本欄位一共有兩種格式:

  * 一個單一的 8 位的 :ruby:`選項型別|option-type`
  * 8 位選項型別 + 8 位的 :ruby:`選項長度|option-length` + 當前的多個 8 位的 :ruby:`選項資料|option-data` 。選項長度是以 8 位為基本單位來計算的包括選項型別欄位、選項長度欄位和選項資料欄位的總長度。

  選項型別欄位又分為三個欄位:

  * 1 位長度的 :ruby:`複製標記|copied flag` ，當置 1 時意味著資料報分片後，當前表示的選項將會複製到所有碎片中。
  * 2 位長度的 :ruby:`選項類別|option class` ，單純的指示選項型別，0 代表控制類，1 和 3 是保留的，2 代表除錯和測量類。
  * 5 位長度的 :ruby:`選項序號|option number` ，這個就基本用來定義那種選項了，具體的可以看 `IP Option Numbers`_

Padding
  顧名思義，這個欄位是用來補全的。IP 頭的總長度需要滿足 32 bits 的倍數，當 options 欄位滿足不了 32 bits 的倍數時，則在其後新增 0 以補全到 32 bits 倍數長度。

:ruby:`分片和重組|Fragmentation and Reassembly`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IP 資料報的傳輸是獨立於底層傳輸技術的，而底層傳輸會因為硬體的不同而導致擁有不同的傳輸速度，以及不同的 :ruby:`最大傳輸單元(MTU)|Maximum Transmission Unit` 。當傳輸的資料報大小超過了當前的 MTU，那麼資料報就可能被分片。不過 IPv6_ 的實現不一樣，下文會有說明。

分片如圖:

.. ditaa::
  :alt: IPv4 分片過程

  * unit is bytes (for data length)
  * header length is 20

                                      a datagram
        +--------+-------------------------------------------------------------+
        | header |                          data (4500)                        |
        +--------+-------------------------------------------------------------+
       |
       |           /-=---------------------------------------------------------------\
   MTU |  /------->| Identification value is the same, Header Checksum is recomputed |<------------------------\
  2500 |  |        \-----------------------------------------------------------------/                         |
       |  |                                        ^                                                           |
       v  :                                        :                                                           |
          |              fragment A                |              fragment B                                   |
        +--------+-------------------------------+--------+------------------------------+                     |
        | header |          data (2480)          | header |          data (2020)         |                     |
        +--------+-------------------------------+--------+------------------------------+                     |
       |  |                                        |                                                           |
       |  :                                        \-=------------\                                            |
       |  |    /-=-------------\                                  :   /-=-------------\                        |
   MTU |  +--->| Flags.MF is 1 |<-----\<---------------------\    \-->| Flags.MF is 0 |<-\                     |
  1500 |  |    \---------------/      |                      |        \---------------/  |                     |
       v  :                           :                      :                           :                     |
          |  fragment C               |  fragment D          |  fragment E               |  fragment F         |
        +--------+------------------+--------+-------------+--------+------------------+--------+------------+ |
        | header |    data (1480)   | header | data (1000) | header |    data (1480)   | header | data (540) | |
        +--------+------------------+--------+-------------+--------+------------------+--------+------------+ |
          |                           |                      |                           |                     |
          +-------------------------->+--------------------->\-=------------------------>\-=-------------------/
          |                           :
          :                           v
          |  /-=--------------------+-=------\
          \->| Fragment Offset is 0 | is 185 | ...
             \----------------------+--------/

圖示已經較為清晰地展示了一個數據報被分片的過程，簡單總結下就是: 當一個路由器接收到一個數據包，它會檢測目標地址並確定傳送該資料包的網絡卡介面以及該介面對應的 MTU，如果資料包長度大於該 MTU 並且 IP 頭的 Flags.DF 欄位為 0，那麼該資料報就可以被分片。分片的最大資料長度為 MTU - Header Length 。分片後所有碎片的 Identification 欄位是一樣的，Total Length 欄位自然會改變，除了最後一個碎片外，其他碎片的 Flags.MF 欄位會置 1，即使後續再次被分片，MF 已經置 1 的碎片被分片後依舊置 1，碎片偏移量計算是前一個碎片的資料長度（不包含 IP 頭）除以 8，最後重新計算每個碎片的 IP 頭校驗和。

至於重組，當資料包滿足以下兩個條件之一即可判斷為碎片:

* Flags.MF 位被置 1
* Fragment Offset 非零

當接收者收到碎片後，會根據碎片 IP 頭資訊內的源/目標地址、協議 ID 和 Identification 欄位來判斷屬於一個數據報的碎片，當接收者接收到本資料報的 Flags.MF 為 0，Fragment Offset 非零的碎片時，會根據這個碎片的偏移量計算出本資料報的資料長度（不包含 IP 頭），計算方法是 :math:`\text{offset of last fragment} \times 8 + \text{data length of last fragment} = \text{total data length (bytes)}` 。當判斷得出獲取的資料報碎片的資料總長度與計算長度相等，則開始按照碎片偏移量對碎片進行重組。

IPv6
----------------------------------------

在 :rfc:`2460` 中定義

合理的 IPv6 地址總數大約有 :math:`3.4 \times 10^{38}` 個，約是 IPv4 地址總數的 :math:`7.9 \times 10^{28}` 倍，可以有效解決目前 IPv4 地址資源匱乏的問題。除了地址更多外，IPv6 還新加了一些 IPv4 下沒有的功能，比如更簡單的地址分配方式（ :ruby:`無狀態地址自動配置|stateless address autoconfiguration` ）。IPv6 的標準化了子網的主機識別符號部分為 64 bits 以方便自動從資料鏈路層獲取地址資訊（ :ruby:`媒體訪問控制(MAC)|media access control` 地址）來格式化它。因為 IPv6 子網的標準大小是 :math:`2^{64}` ，所以實際可用的 IPv6 地址空間會小很多，但也正因為如此，改善了網路管理。

IPv6 頭和 IPv4 頭是不同的，所以也無法互操作，兩個協議版本間的資料交換需要依賴過渡機制，比如 6to4、6in4、Teredo 等，這些就不解釋了。

地址表示
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

詳細的可以看 :rfc:`4291`

地址長度一共是 128 個字，總共分為 8 組每組 16 個字，通常以 16 進位制來表示，比如 **2001:470:00f1:0000:54a8:22a0:e7b0:4f57** 和 **2607:f8b0:4005:080a:0000:0000:0000:2004** 。地址本身可以按照兩條規則來進行簡化:

* 每一個組的從高位開始的連續零可以省略，比如上述的 **00f1** 即可寫成 **f1**，那麼就變成了 **2001:470:f1:0000:54a8:22a0:e7b0:4f57**
* 連續的全為零的組可以用雙引號 **::** 進行替代，帶有多個連續全零組的地址只能替代一次，不然會在解析地址是造成混淆，同時如果全零組是單獨一個則不應該用 **::** 來代替。那麼上述兩個地址最後的簡化形式就是 **2001:470:f1:0:54a8:22a0:e7b0:4f57** 和 **2607:f8b0:4005:80a::2004**。

當一個地址有兩個位置可以簡化為 **::** 時，優先簡化最左邊的，比如 **2001:db8:0:0:1:0:0:1** 應該簡化為 **2001:db8::1:0:0:1** 。

本地迴環地址是 **::1/128** 。

:ruby:`單播/任意播|Unicast/Anycast` 地址一般由一個 64 位的用於路由的網路字首和一個 64 位的用於確定主機網絡卡的介面識別符號位組成，格式如下:

.. ditaa::
  :alt: IPv6 單播/任意播地址組成

            48 bits or more        16 bits or fewer                64 bits
  /--------------------------------+-----------+--------------------------------------------\
  |         routing prefix         | subnet id |             interface identifier           |
  \--------------------------------+-----------+--------------------------------------------/

網路字首又由路由字首和子網 ID 構成，它們的大小是不定的，介面識別符號位的值可以根據介面 MAC 地址以修改過的 EUI-64 [3]_ 格式生成，也可以由 DHCPv6 伺服器生成，也可以自動隨機生成或者手動指定。

:ruby:`本地連結|Link-Local` 地址是用於單鏈接上通訊以實現地址自動配置、鄰居發現等功能的，路由器不應該轉發任何源/目的地址為 Link-Local 地址的資料包，其格式是:

.. ditaa::
  :alt: IPv6 Link-Local 地址組成

    10 bits                54 bits                                 64 bits
  /----------+---------------------------------+--------------------------------------------\
  |1111111010|             zeroes              |             interface identifier           |
  \----------+---------------------------------+--------------------------------------------/

IPv6 的 :ruby:`多播|multicast` 地址是一組介面（通常屬於不同的節點）的識別符號，一個介面也可以屬於任意個多播組。多播地址格式如下:

.. ditaa::
  :alt: IPv6 多播地址組成

   8 bits  4 bits  4 bits                             112 bits
  /--------+------+------+------------------------------------------------------------------\
  |11111111| flgs | scop |                         group identifier                         |
  \--------+------+------+------------------------------------------------------------------/

flgs 欄位是 4 個標籤的組合，從高到低依次為:
  
+-+-+-+-+
|0|R|P|T|
+-+-+-+-+

* 最高位目前為保留字，初始化為零。
* R 位的定義和使用在 :rfc:`3956` 。
* P 位的定義和使用在 :rfc:`3306` 。
* T 位為 1 意味著這是一個被 IANA （ :ruby:`網際網路號碼分配機構|Internet Assigned Numbers Authority` ）永久分配的多播地址，為 0 意味著是一個非永久分配的多播地址。

scop 欄位用於限制多播地址的適用範圍，不看了，需要的時候直接再看 RFC 吧，以及相關的常用 `Multicast addresses`_ 。

一類比較特殊的單播地址是 ULA （ :ruby:`唯一本地地址|Unique Local Address` ），類似於 IPv4 的私有地址，可用於私有網路，地址欄位是 **fc00::/7** ，無法在全球網路上被定址到，定義在 :rfc:`4193` 。注意的是雖然說其可以被分為兩個 **/8** 的地址組，但目前僅 **fd00::/8** 可以被本地分配， **fc00::/8** 則可能會在將來被另外定義。

而有關任意播地址的保留地址，有如下幾種（相關的 RFC 有 :rfc:`2373` 和 :rfc:`2526` ）:

* 子網路由的任意播地址，在語法上就類似把普通單播地址的介面標識段全置 1，當資料包傳送到子網路由的任意播地址時，資料包會發送到該子網的一個路由器上，比如當移動主機需要與其子網的一個移動代理通訊的時候，其格式為:

.. ditaa::
  :alt: 子網路由任意播地址組成

                        n bits                                       128−n bits
  /----------------------------------------------------+------------------------------------\
  |                  subnet prefix                     |       0000000000...00000000        |
  \----------------------------------------------------+------------------------------------/

* 其它保留的子網任播地址格式分為兩種

  * 一種是噹噹前子網介面標誌段是 64 位的修改版 EUI-64 [3]_ 格式時，介面標識段從高位數第 7 位的 universal/local 位必須置 0，表示地址不是全域性唯一的，對應欄位的其它位全置 1。詳細的格式為:

  .. ditaa::
    :alt: 保留子網任意播地址組成0

                        64 bits                                57 bits                7 bits
    /--------------------------------------------+---------------------------------+----------\
    |                subnet prefix               |         111111011...111         |anycast ID|
    \--------------------------------------------+---------------------------------+----------/
  
  * 另一種是子網介面標識段非修改版 EUI-64 [3]_ 格式並且連長度也可以不等於 64 位，相比而言，介面標識段除了最低位數的 7 位其他全置 1，其格式為:

  .. ditaa::
    :alt: 保留子網任意播地址組成1

                          n bits                              121−n bits               7 bits
    /--------------------------------------------+---------------------------------+----------\
    |                subnet prefix               |         111111111...111         |anycast ID|
    \--------------------------------------------+---------------------------------+----------/
  
  * 就這兩種格式的相同欄位做說明，子網字首就是和普通單播地址的子網字首一樣處理對待。最低位的 7 位的任播 ID 則確定了當前子網下一個特定的任播地址，目前僅 **0x7e** 是一個已經被定義的任播 ID，代表 :ruby:`移動 IPv6 家代理任播|Mobile IPv6 Home-Agents anycast` ，其他 **0x00-0x7d** & **0x7f** 都是保留中。
  
其他保留地址可以看 `Reserved IPv6 addresses`_ 。

為了更高效的 :ruby:`路由聚合|route aggregation` ，目前分配在網際網路上可用的 IPv6 地址只有全部的八分之一，為 **2000::/3** ，剩下的地址則有用於其他目的或者留給了今後使用。

IP 頭及欄位說明
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

相對於 IPv4 的一些主要改變:

* 長度是 IPv4 頭的至少兩倍，但是因為一些簡化處理機制，路由在處理 IPv6 頭的時候反而更加高效。
* 不再實現路由上的 IP 分片，主機本身可以做 PMTUD 來確保傳送資料包足夠小以使得可以到達目標端，或者直接傳送小於預設 MTU(1280 bytes) 的包。
* 沒有了頭校驗和，校驗由鏈路層和更高一層協議合作完成，注意的是在 IPv4 中 UDP 校驗和為 0，也就是沒有校驗的，但是在 IPv6 中必須要實現校驗。
* TTL 欄位更名為 Hop Limit 以符合其實際的身份。

固定頭格式
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|bit| 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
+===+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+
|  0|  Version  |     Traffic Class     |                        Flow Label                         |
+---+-----------+-----------------------+-----------+-----------------------+-----------------------+
| 32|                 Payload Length                |      Next Header      |       Hop Limit       |
+---+-----------------------------------------------+-----------------------+-----------------------+
| 64|                                                                                               |
+---+                                                                                               |
| 96|                                                                                               |
+---+                                         Source Address                                        |
|128|                                                                                               |
+---+                                                                                               |
|160|                                                                                               |
+---+-----------------------------------------------------------------------------------------------+
|192|                                                                                               |
+---+                                                                                               |
|224|                                                                                               |
+---+                                      Destination Address                                      |
|256|                                                                                               |
+---+                                                                                               |
|288|                                                                                               |
+---+-----------------------------------------------------------------------------------------------+

欄位說明:

Version
  4 位的固定 IP 版本 0110(6)。

Traffic Class
  8 位的這個通訊型別段被分成 6 位的 DSCP 欄位和 2 位的 ECN 欄位，功能參見 IPv4 對應欄位說明。

Flow Label
  20 位的流標籤欄位被髮信端用來標記資料包的序列以暗示路由/交換機在存在多個出口通路的情況下走固定的通路以避免包被重新排序，一般用於實時應用。

Payload Length
  16 位的負載長度欄位是用於表示包括擴充套件頭在內的所有 IPv6 負載的長度的。當本資料包有攜帶 :ruby:`特大包|Jumbogram` 負載選項的 :ruby:`逐跳|Hop-by-Hop` 選項擴充套件頭時，本欄位長度需置 0。

Next Header
  顧名思義，表示緊接著的下一個 header 的型別，可以是高一層（傳輸層）對應負載的頭型別，也可以是本層的相關頭型別（比如 ICMPv6），也可以是擴充套件頭型別。型別序號是和 IPv4 Protocol 欄位所對應的共享的，同樣可以看 `List of IP Protocol Number`_ 。

Hop Limit
  替代了 IPv4 的 TTL 欄位，當資料包每經過一箇中間節點便把值減一，當為 0 時，丟棄該資料包。

Source Address
  傳送端的 IPv6 地址

Destination Address
  接收端的 IPv6 地址

擴充套件頭
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

與 IPv4 不同，IPv6 的可選網路層資訊是存放在一個單獨的介於 IPv6 頭和對應負載頭（比如 TCP、IMCPv6 等）之間的擴充套件頭裡面的。一個 IPv6 資料包可以包含零、一或者多個擴充套件頭，包含多個擴充套件頭時的資料包可以如圖表示:

.. ditaa::
  :alt: IPv6 擴充套件頭

     IPv6 header   Routing header  Fragment header  Fragment of TCP
          |               |               |               |
          :               :               :               :
  +---------------+---------------+---------------+-----------------+
  |cGRE  ...      | /-----------\ | /-----------\ |c1EE             |
  | /-----------\ | |Next Header| | |Next Header| |                 |
  | |Next Header| | |-=---------| | |-=---------| |                 |
  | |-=---------| | |  Fragment | | |    TCP    | |  Header + Data  |
  | |  Routing  | | \-----------/ | \-----------/ |                 |
  | \-----------/ |      ...      |      ...      |                 |
  |      ...      |               |               |                 |
  +---------------+---------------+---------------+-----------------+

值的注意的是，擴充套件頭不會在資料包傳輸過程中被處理，並且在目的地接收到本次資料包後，會依次處理擴充套件頭而不能跳過某一個直接處理下一個。但有一個例外必須在傳輸過程中被所有節點處理的，那便是 Hop-by-Hop Options 頭，當存在這個頭時，該頭必須緊跟在 IPv6 固定頭後面。

為了使後續的頭可以繼續保證按照 8 位元組邊界對齊，每一個擴充套件頭的長度必須為 8 位元組的倍數。

當一個節點無法識別 Next Header 欄位的值或者在非固定頭的 Next Header 欄位識別到 0 時，需要向資料包的傳送源傳送程式碼值為 1 （ 1 代表「遇到無法識別的 Next Header 型別」）的 ICMP :ruby:`引數問題|Parameter Problem` 資訊，並將該 ICMP 資訊的指標欄位值設定為無法識別的欄位相對於原始 IPv6 包的偏移量。

建議的資料包內擴充套件頭連線順序如下（強烈建議）:

* (IPv6 header)
* Hop-by-Hop Options header (0)
* Destination Options header (60)
* Routing header (43)
* Fragment header (44)
* Authentication header (51)
* Encapsulating Security Payload header (50)
* Destination Options header (60)
* （負載協議頭）

除了 Destination Options header 最多可以出現兩次之外，其他的擴充套件頭最多隻能出現一次。上述說明的順序以及出現次數是一個建議的並非強制的（除了 Hop-by-Hop Options 必須緊跟 IPv6 頭之後出現且僅能出現一次之外），節點也應該要有處理非建議順序/次數擴充套件頭的能力。

當 Next Header 欄位的值為十進位制的 59 時，代表沒有其他的頭/負載跟在這個後面了，IPv6 包在這個頭結束。如果說 IPv6 頭的負載長度大於所有擴充套件頭的長度的話，那麼意味著還是有負載在這個 IPv6 的資料包下的，這種情況下，本資料包經過的路由器並不會來處理這些負載，但主機則會忽略掉這些負載。

大多數擴充套件頭的通用格式可以看 :rfc:`6564` ，已經定義的是不被這個 RFC 所描述的，又其是 Fragment Header，相去甚遠。下面來描述常用的擴充套件頭:

IPv6 擴充套件頭的 :ruby:`選項型別|Option Type` 八位的前三位有單獨的定義及說明，詳細的看 :rfc:`2460` 4.2 節。

Hop-by-Hop Options header 和 Destination Options header 都是用來攜帶可選資訊的，只不過前者攜帶的資訊會被經過的每一個節點所處理，而後者攜帶的資訊僅會被目的節點所處理，它們的擴充套件頭結構相同，如下:

+---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|bit| 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
+===+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+
|  0|      Next Header      |      Hdr Ext Len      |              Options and Padding              |
+---+-----------------------+-----------------------+-----------------------------------------------+
| 32|                                      Options and Padding                                      |
+---+-----------------------------------------------------------------------------------------------+
| 64|                                  Optional Options and Padding                                 |
+---+                                              ...                                              |
|...|                                                                                               |
+---+-----------------------------------------------------------------------------------------------+

依次來說明欄位:

Next Header
  和 IPv6 頭的同名欄位一致，表示下一個頭的型別

Hdr Ext Len
  表示當前這個擴充套件頭的長度，注意計算時不包括最開始的 8 個位元組，也就是 :math:`\text{Actual Lenght (bytes)} = (\text{Hdr Ext Len} + 1) \times 8` 。同時也意味著最小的長度為 8 個位元組。

Options
  包含了一個或者多個的 :ruby:`型別-長度-值|Type-Length-Value` (TLV)編碼的選項。同時在當選項長度不足以滿足 8 個位元組的倍數時填充 padding。

Padding
  分兩種格式:

  * Pad1 格式，長度為一個位元組，值為零，可以理解為就是填充了一個位元組的零。
  * PanN 格式，區分於上述格式，當需要的 padding 大於一個位元組的時候，不應該填充多個 Pad1 而是應該使用 PadN，詳細欄位格式如下:

  +---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+---+
  |bit| 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|...|
  +===+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+===+
  |  0|           1           |      Opt Data Len     |     **ZERO** ...       |
  +---+-----------------------+-----------------------+------------------------+

  第一個位元組為型別， Opt Data Len 代表本 PadN 欄位從第 16 位開始需要填充多少位元組的零，這樣子就可以實現 2 位元組到 N(N>2) 位元組的填充了。
  
當傳送端需要傳送的資料包大於鏈路上的 MTU 時，傳送端會把資料分片，然後將碎片作為單獨的資料包傳送，並將相關資訊存放在 Fragment 擴充套件頭中（而傳送路徑中間節點不會對資料包做任何分片操作，上述已有相關說明）。本擴充套件頭格式如下:

+---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|bit| 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
+===+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+
|  0|      Next Header      |        Reserved       |           Fragment Offset            | Res | M|
+---+-----------------------+-----------------------+--------------------------------------+-----+--+
| 32|                                        Identification                                         |
+---+-----------------------------------------------------------------------------------------------+

欄位說明:

Next Header
  和之前一樣，表示下一個頭的型別

Reserved
  保留欄位，初始化為零，接收時會忽略

Fragment Offset
  這個 13 位的欄位儲存的值是以 8 位元組為一個單位來表示的，代表了本擴充套件頭後跟的資料相對於原始資料包的偏移量。

Res
  保留欄位，初始化為零，接收時會忽略

M
  這是一個標記， 1 代表還有更多的碎片， 0 代表這是最後一個碎片。

Identification
  這個 32 位的欄位是用於區分不同原始包的碎片的。每當傳送端判斷一個數據包需要被分片的時候變生成一個（一般是較上一個相同源/目的地址的碎片的 ID 加一，並迴圈計數）。接收端則根據此 ID 以及源/目的地址判斷相同的原始資料包。

其他的擴充套件頭可以看對應的 RFC。


無狀態地址自動配置(SLAAC)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

當節點的系統啟動時，該節點會自動為每一個啟用 IPv6 的介面建立一個字首為 **fe80::/64** 的 Link-Local 地址，這個過程利用了鄰居發現協議 [4]_ 的一個元件，是獨立的和 SLAAC 無關的。主機會發送一個 :ruby:`路由請求資訊|Router Solicitation message` 到路由器，然後路由器會返回一條 :ruby:`路由公告資訊|Router Advertisement message` 給主機，一般攜帶一個 64 位地址字首，而低 64 位的介面標識段則根據修改過的 EUI-64 [3]_ 格式生成。

當地址生成好了之後，生成的地址被稱為嘗試性地址，為了確保地址的唯一性，本節點會加入到當前嘗試性地址的 :ruby:`被請求節點多播地址組|Solicited-node multicast address` 以及面向所有主機的多播地址 **ff02::1/128** 組中，並以當前嘗試性地址為目標地址，未指定地址 **::/128** 為源地址傳送 :ruby:`鄰居請求資訊|Neighbor Solicitation message` 。只有當本節點既沒有收到以當前嘗試性地址為目標地址的鄰居請求資訊，也沒有收到以當前嘗試性地址為源地址的 :ruby:`鄰居公告資訊|Neighbor Advertisement message` 時，才算確定了地址的唯一性。

每一個 IPv6 地址都會有生命週期，在沒有被配置的情況下是無限長的。如果要配置的話，可以被路由器返回的路由公告(RAs)所配置，也可以手動修改，地址的生命週期可以被 RAs 所更新。如果地址沒有被更新或者就是達到了生命週期限制了，那麼該地址就會被棄用，不會再有連線使用這個地址直到再次被分配。

當使用 SLAAC 時，預設的介面標識欄位由對應的介面 MAC 地址所調整而來，這樣子就可以根據當前 IPv6 地址長期追蹤到單獨的一臺機器，甚至一個使用者。為了避免使用者身份和一個 IPv6 地址長期繫結在一起，節點也可以以基於時間的隨機數為基礎來生成介面標識段並賦予該地址一個較短的生命週期。

**TODO**: *詳解鄰居發現協議以及 ICMPv6*

**TODO**: *整理同一網絡卡多個 IPv6 地址時，預設地址選擇問題* ，參考 :rfc:`6724`

TCP
==============================

未完

UDP
==============================

未完

未完

註解
==============================

.. [1] OSI 參考模型中定義了在網路層的資料單元是 :ruby:`資料包|packet` ，但是 IP 定義其傳輸的資料名為 :ruby:`資料報|datagram` ，所以兩者在本文會存在互用的情況。個人認為，資料包不一定是資料報，但 IP 資料報一定是資料包。
.. [2] 反碼也被成為一補數/一補碼，在做相加/減運算時，即使沒有計算溢位，也會因為出現 :ruby:`迴圈進位|end-around carry` 或者 :ruby:`迴圈借位|end-around borrow` 而導致運算錯誤，所以當出現這兩種情況時，需要把超出部分的 bit 加/減到中間結果的最右，以得到最後結果。而大部分計算機整數運算時所採用的 :ruby:`補碼|two's complement` （也被稱為二補數）則沒有這個問題。
.. [3] EUI( :ruby:`擴充套件唯一識別符號|Extended Unique Identifier` )-64 是 IEEE 所宣告的商標，是形成 MAC 地址的規則之一。其一般派生自對應的 48 位的識別符號，在 48 位識別符號中間插入 **FF:FE** 即可，比一個 48 位的識別符號 **50:6a:03:cb:1b:0b** 所對應的 64 位識別符號為 **50:6a:03:ff:fe:cb:1b:0b** 。而當需要用於表示 IPv6 的介面標識段的值時還需要進一步修改，修改方法是把 EUI-64 地址的從高位數第 7 位（ Universal/Local 位）取反，那麼就變成了 **52:6a:03:ff:fe:cb:1b:0b** ，針對一個網路字首為 **2001:470:f1:0:** 的 IPv6 地址，此時完整的表示就是 **2001:470:f1:0:526a:03ff:fecb:1b0b** 。
.. [4] :ruby:`鄰居發現協議|Neighbor Discovery Protocol` (NDP,ND) 工作在 TCP/IP 參考模型的鏈路層，結合 IPv6 一起使用，其任務是有，自動配置節點地址、發現鏈路上的其它節點、確定其它節點的地址、重複地址檢測、發現可用路由器及 DNS 伺服器、發現地址字首（子網字首？）、維護其它已經啟用的鄰居節點的可達性資訊。

.. _`List of IP Protocol Number`: https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
.. _`IP Option Numbers`: https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml
.. _`Multicast addresses`: https://en.wikipedia.org/wiki/IPv6_address#Multicast_addresses
.. _`Reserved IPv6 addresses`: https://en.wikipedia.org/wiki/Reserved_IP_addresses#IPv6
